package com.github.mengweijin.quietly.system.entity;

import com.baomidou.mybatisplus.annotation.TableName;
import com.baomidou.mybatisplus.annotation.TableField;
import com.fasterxml.jackson.databind.annotation.JsonSerialize;
import com.fasterxml.jackson.databind.ser.std.ToStringSerializer;
import com.github.mengweijin.quickboot.mybatis.entity.BaseEntity;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.experimental.Accessors;

/**
 * <p>
 * QTL_STEP_DEFINITION
 * </p>
 *
 * @author mengweijin
 * @since 2022-05-03
 */
@Data
@EqualsAndHashCode(callSuper = true)
@Accessors(chain = true)
@TableName("QTL_STEP_DEFINITION")
public class StepDefinition extends BaseEntity {

    private static final long serialVersionUID = 1L;

    /**
     * QTL_CASE_DEFINITION id
     */
    @JsonSerialize(using = ToStringSerializer.class)
    @TableField("CASE_ID")
    private Long caseId;

    /**
     * 执行步骤类型(表 QTL_DICT_TYPE 的 code=case_step_type 的类型)，关联表 QTL_DICT_DATA 的 id
     */
    @JsonSerialize(using = ToStringSerializer.class)
    @TableField("STEP_TYPE_DATA_ID")
    private Long stepTypeDataId;

    /**
     * 行为表达式。执行SQL就是具体的SQL语句；调用接口就是关联的表QTL_API_DEFINITION的 id；
     */
    @TableField("ACTION_EXPRESSION")
    private String actionExpression;

    /**
     * 执行SQL关联的数据库 QTL_ENVIRONMENT_DATASOURCE id.
     */
    @JsonSerialize(using = ToStringSerializer.class)
    @TableField("ACTION_SQL_DATASOURCE_ID")
    private String actionSqlDatasourceId;

    /**
     * 调用接口 url 参数JSON。以 ${} 作为占位符来引用上一个执行步骤传递过来的参数。如：http://localhost:8080/quietly?username=${username}。
     */
    @TableField("ACTION_API_URL_ARGS")
    private String actionApiUrlArgs;

    /**
     * 调用接口请求体参数JSON。以 ${} 作为占位符来引用上一个执行步骤传递过来的参数。可以从表 QTL_API_DEFINITION 中获取 API 默认参数并合并到这里。
     */
    @TableField("ACTION_API_BODY_ARGS")
    private String actionApiBodyArgs;

    /**
     * 调用接口请求头参数JSON。以 ${} 作为占位符来引用上一个执行步骤传递过来的参数。可以从表 QTL_API_DEFINITION 中获取 API 默认参数并合并到这里。
     */
    @TableField("ACTION_API_HEADERS")
    private String actionApiHeaders;

    /**
     * 断言表达式字符串和JSON断言用不到这个字段；JSON-Path和XML-Path 就是其对应的语法。
     */
    @TableField("ASSERT_EXPRESSION")
    private String assertExpression;

    /**
     * Expect value.
     */
    @TableField("ASSERT_EXPECT_VALUE")
    private String assertExpectValue;

    /**
     * Actual value
     */
    @TableField("ASSERT_ACTUAL_VALUE")
    private String assertActualValue;

    /**
     * The execution order of steps, generated by the program.
     */
    @TableField("SEQ")
    private Integer seq;

    /**
     * 逻辑删除。0：未删除；1：已删除；
     */
    @TableField("DELETED")
    private Integer deleted;

    /**
     * 备用字段。如果用户需要自定义 Step 定义的话，上面这些字段可能不够，所以留几个备用字段。
     */
    @TableField("FIELD_1")
    private Integer field1;

    /**
     * 备用字段。如果用户需要自定义 Step 定义的话，上面这些字段可能不够，所以留几个备用字段。
     */
    @TableField("FIELD_2")
    private Integer field2;
    /**
     * 备用字段。如果用户需要自定义 Step 定义的话，上面这些字段可能不够，所以留几个备用字段。
     */
    @TableField("FIELD_3")
    private Integer field3;
    /**
     * 备用字段。如果用户需要自定义 Step 定义的话，上面这些字段可能不够，所以留几个备用字段。
     */
    @TableField("FIELD_4")
    private Integer field4;
    /**
     * 备用字段。如果用户需要自定义 Step 定义的话，上面这些字段可能不够，所以留几个备用字段。
     */
    @TableField("FIELD_5")
    private Integer field5;
    /**
     * 备用字段。如果用户需要自定义 Step 定义的话，上面这些字段可能不够，所以留几个备用字段。
     */
    @TableField("FIELD_6")
    private Integer field6;
}
